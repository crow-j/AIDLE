import os
import numpy as np
import pandas as pd

#!pip install eml_parser

import datetime
import eml_parser

### json 형태(디렉토리(객체) 또는 리스트(배열))로된 값을 DataFrame 형태로 변환 ###
# 디렉토리와 리스트가 아닌 string 또는 datetime 타입의 값이 나올때까지 검사
# string 또는 datetime값이 나오면 해당 key와 value를 DataFrame으로 바꾼 후 리턴
# 계속해서 열이 추가되도록 concat 사용
def toDataFrame(idx, key, value, column):
    col = column + '/' + key
    eml_df = pd.DataFrame()
    
    if type(value) == type(dict()):
        for k in value:
            eml_df = pd.concat([eml_df, toDataFrame(idx, k, value[k], col)], axis=1)
            
    elif type(value) == type(list()):
        # received의 개수를 last_num 열에 추가
        if col == '/header/received':
            num = len(value)
            eml_df = pd.concat([eml_df, pd.DataFrame(data={'last_num':num}, index=[idx])], axis=1)

        v = ''
        for i, d in enumerate(value):
            if type(d) == type(dict()):
                eml_df = pd.concat([eml_df, toDataFrame(idx, str(i), d, col)], axis=1)
                
            else:   # str, email.headerregistry._ContentTypeHeader, ...
                v += ' ' + d
        eml_df = pd.concat([eml_df, pd.DataFrame(data={col: v}, index=[idx])], axis=1)
    
    else:     #str, datetime.datetime, ...
        eml_df = pd.DataFrame(data={col: value}, index=[idx])
        
    return eml_df
    
### 인자로 받은 line이 필드(필드 이름과 필드 값으로 구성된 것)인지 확인
### 참고자료: http://cr.yp.to/immhf/field.html
def isField(line):
    field = line.split(':')
    answer = True
    if len(field) == 2:     
        fieldName = field[0]
        for word in fieldName:
            if ord(word) <= 33 or ord(word) >= 126:
                answer = False
    else:
        answer = False
    
    return answer
    
### 인자로 받은 eml 파일의 내용을 한줄씩 읽어 <html>부터 </html>까지 하나의 column('html')에 저장하여 반환 ###
def content_parsing(idx, file_path):
    header = {}
    f = open(file_path, 'r', encoding='utf-8' )
    iscontent = False
    header['content'] = ''
    while True:
        line = f.readline()
        if not line:
            break
        
        ######## 수정할 예정(body 부분에 존재하는 필드(content가 아닌 부분)까지 저장되는 문제 존재) ########
        # 하나의 eml 파일에 content가 여러개 존재하는 경우 있음(/header/header/content-type 이 'multipart'인 경우로 추정
        # 그런 경우 body안에 content 별로 필드(ex. content-type, content-transfer-encoding, ...)가 존재
        # header의 content type에 따라 content를 파싱하는 방법을 달리할 예정
        if '\n' == line or not (line[0]==' ' or line[0]=='\t' or isField(line)):
            iscontent = True
        if iscontent == True:
            header['content'] += line
            #if '<html>' in line:
            #    ishtml = False
    return pd.DataFrame(data=header, index=[idx])
    
### 인자로 받은 디렉토리(folder)에 있는 파일들 중 선택된 파일들에 대해 파싱한 후 DataFrame으로 저장 ###
def parsing(folder):
    file_list = os.listdir(folder)
    
    emls_df = pd.DataFrame()    
    count = 0
    
    for i, file in enumerate(file_list):
        # 원하는 파일이 아니면 제외(원하는 파일 선택)
        # 생각보다 오래걸릴 수 있어서 file[0:2] == '01' 과 같이 더 나눠서 반복해서 실행시키는 것 추천
        if not (file[0:3] == '0b2' or file[0:3] == '0b3'):  # 각자 시작하는 16진수 선택
            continue
        
        if count%100 == 0:     # 진행 상태 확인(100개 단위로 file 이름 print)
            print(file)
        count += 1
        
        #### eml-parsing ####
        # eml-parsing을 이용해서 eml 파일의 header와 body(html(X)) 부분을 파싱 (메일 header & body 파싱)
        file_path = os.path.join(folder, file)
        with open(file_path, 'rb') as fhdl:
          raw_email = fhdl.read()

        ep = eml_parser.EmlParser()
        # error가 발생해도 나머지 파일들에 대한 파싱값 저장하기 위해 try-except 사용
        try:
            parsed_eml = ep.decode_email_bytes(raw_email)   # 파싱한 결과가 담긴 변수(parsed_eml), 디렉토리 형태
        except AttributeError as e:
            # 특정 eml 파일에 대해 에러발생했음
            # 이유는 모르겠어서 그냥 file명 출력
            print('=== AssertionError:', e, '(during eml_parser) ===')
            print('error file:', file)
    
        #### to DataFrame ####
        # parsed_eml에 들어있는 파싱된 정보들을 pandas dataframe으로 저장하기
        # toDataFrame 함수 이용
        if type(parsed_eml['body']) != type(list()):
            print('body type ', type(parsed_eml['body']))
        else:
            eml_df = toDataFrame(i, 'body', parsed_eml['body'], '')
            
        if type(parsed_eml['header']) != type(dict()):
            print('header type ', type(parsed_eml['header']))
        else:
            # 이전의 eml_df와 병합, eml_df에 header와 관련된 열들 추가
            eml_df = pd.concat([eml_df, toDataFrame(i, 'header', parsed_eml['header'], '')], axis=1)
            
        #### content-parsing ####
        # eml 파일의 content 부분을 파싱하여 DataFrame 'content_n'열에 저장할 예정(하나의 파일에 content 여러개 있을 수 있음)
        # content-parsing 함수(수정중...) 이용
        # 이전의 eml_df와 병합, eml_df에 'html'열 추가
        eml_df = pd.concat([eml_df, html_parsing(i, file_path)], axis=1)
        
        # error가 발생해도 나머지 파일들에 대한 파싱값 저장하기 위해 try-except 사용
        try:
            emls_df = pd.concat([emls_df, eml_df])  
        except ValueError as e:
            # 하나의 dataframe에 중복된 열이름이 있을 경우 concat할 때 error 발생
            # 열이름 확인을 위해 eml_df의 열 print
            print('=== ValueError:', e, '(during concat) ===') # error 문구, 마음대로 변경 가능, e변수에 error 내용 저장
            print('error file name:', file)
            print(parsed_eml)
            for c in eml_df.columns:
                print(c)
            print()
        except AssertionError as e:
            print('=== AssertionError:', e, '(during concat) ===') # error 문구, 마음대로 변경 가능, e변수에 error 내용 저장
            print('error file name:', file)
            
    return emls_df
    
eml_df = parsing('dataset/eml') # 파싱할 eml 파일들이 있는 디렉토리 경로입력
eml_df.to_csv('./test.csv',encoding='utf-8-sig')
